import{_ as o}from"./plugin-vue_export-helper-c27b6911.js";import{r as t,o as s,c,a as e,b as a,d,f as i}from"./app-d2bd0ec7.js";const l={},r=e("h1",{id:"java-se-要点",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#java-se-要点","aria-hidden":"true"},"#"),a(" Java SE 要点")],-1),p=e("h2",{id:"枚举",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#枚举","aria-hidden":"true"},"#"),a(" 枚举")],-1),u={href:"https://blog.csdn.net/x_iya/article/details/53291536",target:"_blank",rel:"noopener noreferrer"},h=i(`<p>详细：答案是肯定的，因为枚举有着严格的实例化控制，所以你可以用 <code>==</code> 去做比较符，这个用法，在官方文档中也有明确的说明。而且枚举equals（）方法的底层就是用==判断。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>    <span class="token doc-comment comment">/**
     * Returns true if the specified object is equal to this
     * enum constant.
     *
     * <span class="token keyword">@param</span> <span class="token parameter">other</span> the object to be compared for equality with this object.
     * <span class="token keyword">@return</span>  true if the specified object is equal to this
     *          enum constant.
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> other<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token operator">==</span>other<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>基础类型的包装类型也用 <code>==</code> 判断</p><h2 id="pattern-compile函数的用法" tabindex="-1"><a class="header-anchor" href="#pattern-compile函数的用法" aria-hidden="true">#</a> Pattern.compile函数的用法</h2><p>在使用<code>Pattern.compile</code>函数时，可以加入控制正则表达式的匹配行为的参数： <code>Pattern Pattern.compile(String regex, int flag) </code></p><p>flag的取值范围如下：</p><ul><li><code>Pattern.CANON_EQ</code> 当且仅当两个字符的&quot;正规分解(canonical decomposition)&quot;都完全相同的情况下，才认定匹配。比如用了这个标志之后，表达式&quot;\\u030A&quot;会匹配?。默认情况下，不考虑规范相等性(canonical equivalence)&quot;。</li><li><code>Pattern.CASE_INSENSITIVE</code> 默认情况下，大小写不明感的匹配只适用于US-ASCII字符集。这个标志能让表达式忽略大小写进行匹配。要想对Unicode字符进行大小不明感的匹 配，只要将UNICODE_CASE与这个标志合起来就行了。</li><li><code>Pattern.COMMENTS</code> 在这种模式下，匹配时会忽略(正则表达式里的)空格字符(译者注：不是指表达式里的&quot;\\s&quot;，而是指表达式里的空格，tab，回车之类)。注释从#开始，一直到这行结束。可以通过嵌入式的标志来启用Unix行模式。</li><li><code>Pattern.DOTALL</code> 在这种模式下，表达式&#39;.&#39;可以匹配任意字符，包括表示一行的结束符。默认情况下，表达式&#39;.&#39;不匹配行的结束符。</li><li><code>Pattern.MULTILINE</code> 在这种模式下， <code>^</code> 和 <code>$</code> 分别匹配一行的开始和结束。此外，<code>^</code> 仍然匹配字符串的开始，<code>$</code> 也匹配字符串的结束。默认情况下，这两个表达式仅仅匹配字符串的开始和结束。</li><li><code>Pattern.UNICODE_CASE</code> 在这个模式下，如果你还启用了CASE_INSENSITIVE标志，那么它会对Unicode字符进行大小写不明感的匹配。默认情况下，大小写不敏感的匹配只适用于US-ASCII字符集。</li><li><code>Pattern.UNIX_LINES</code> 在这个模式下，只有&#39;\\n&#39;才被认作一行的中止，并且与<code>.</code>，<code>^</code>，以及<code>$</code>进行匹配。</li></ul><h2 id="lamda表达式" tabindex="-1"><a class="header-anchor" href="#lamda表达式" aria-hidden="true">#</a> lamda表达式</h2><h3 id="parallelstream" tabindex="-1"><a class="header-anchor" href="#parallelstream" aria-hidden="true">#</a> ParallelStream</h3><p>​ <code>parallelStream</code> 是 Java lamda表达式当中并行流写法，本质上并行方法，效率很高，但是需要注意会产生多线程下的各种问题，比如使用非线程安全的集合类，会导致空指针和数组下标越界等问题。如果使用<code>.collect</code>最终将结果收集起来就不会有个这个问题或者使用<code>CopyOnWriteArrayList</code>， <code>CopyOnWriteArraySet</code> 这类线程安全的集合来避免问题。千万不能使用 <code>parallelStream</code> 去循环处理非线程安全的流程。</p>`,10);function m(v,_){const n=t("ExternalLinkIcon");return s(),c("div",null,[r,p,e("blockquote",null,[e("p",null,[a("原文："),e("a",u,[a("枚举为什么可以用==判断相等"),d(n)])])]),h])}const f=o(l,[["render",m],["__file","Java SE要点.html.vue"]]);export{f as default};
